#  png中CRC计算--9.29
## 关于CRC原理  
1. A端  
    1. 选择指定的CRC参数模型
    2. 根据模型参数及实际数据计算CRC值【1】
    3. 将 数据+CRC 以及其他部分存储或发送
2. B端
    1. 获取读取或接受的 数据+CRC【1】
    2. 选择指定的CRC参数模型
    3. 根据模型参数及实际数据计算CRC值【2】
    4. 将CRC【2】与CRC【1】进行比对
    5. 若相同，则数据正确；若不同，则数据有损

## CRC模型参数
|参数|取值|意义|
|---|---|---|
|NAME|根据位宽具体取名|参数模型名称|
|WIDTH|4、5、6、7、8、16、32等|CRC数据位宽|
|POLY|据具体模型而定|省略最高次系数后多项式所有系数的十六进制表示|
|INIT|通常为全0或F|CRC初始值|
|REFIN|true或false|计算前是否翻转|
|REFOUT|true或false|计算后CRC是否翻转|
|XOROUT|通常为全0或F|与计算后CRC进行异或运算|

常见21个模型  
![21个标准参数模型](./img/CRC参数模型.png)  

具体实例：  
```
0.原始数据 = 0x34 = 0011 0100，多项式 = 0x31 = 1 0011 0001
1.INIT = 00，原始数据高8位和初始值进行异或运算保持不变。
2.REFIN为TRUE，需要先对原始数据进行翻转：0011 0100 > 0010 1100
3.原始数据左移8位，即后面补8个0：0010 1100 0000 0000
4.把处理之后的数据和多项式进行模2除法，求得余数：
原始数据：0010 1100 0000 0000 = 10 1100 0000 0000
多项式：1 0011 0001
模2除法取余数低8位：1111 1011
5.与XOROUT进行异或，1111 1011 xor 0000 0000 = 1111 1011 
6.因为REFOUT为TRUE，对结果进行翻转得到最终的CRC-8值：1101 1111 = 0xDF
7.数据+CRC：0011 0100 1101 1111 = 34DF，相当于原始数据左移8位+余数。
```


## png数据块结构
|名称|长度|作用|
| ---| --- |--- |
|Length|4 bytes|指定Chunk Data的长度|
|Chunk Type|4 bytes|指定数据块类型|
|Chunk Data|由Length指定|按照Chunk Type存放指定数据|
|CRC|4 bytes|检查是否有错误的循环冗余代码| 


## 利用zlib提供的crc32计算
```python
from zlib import crc32

crc = crc32(bytes, value)
# png中 bytes 取数据块的Chunk Type和Chunk Data，value 取 0
```
